var Person = /** @class */ (function () {
    function Person(firstname, lastname) {
        this.firstname = firstname;
        this.lastname = lastname;
    }
    Object.defineProperty(Person.prototype, "age", {
        get: function () {
            if (this._age === undefined) {
                throw new Error("The age property has not been set as yet");
            }
            return this._age;
        },
        // I need a better way to set the age of the person
        // The logic needs to be encapsulated inside a method separate from constructor
        set: function (age) {
            if (age > 200 || age < 0) {
                throw new Error("The age must be within range of 0-200");
            }
            this._age = age;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Person.prototype, "fullname", {
        get: function () {
            return "".concat(this.firstname, " ").concat(this.lastname);
        },
        enumerable: false,
        configurable: true
    });
    return Person;
}());
var john = new Person("John", "Doe");
var mark = new Person("Mark", "Doe");
john.age = 50;
mark.age = 30;
// We can access the age like a property even though there is a method behind the scenes
// that is working to fetch the age for us using one of the private properties of a class
console.log(john.age);
console.log(mark.age);
// Now full name can be access on a class as if if was the property of the class
console.log(john.fullname);
